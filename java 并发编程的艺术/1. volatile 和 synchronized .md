###  volatile

####  volatile作用：

​	volatile保证了共享变量的可见性。
​	可见性：当一个线程修改一个共享变量时，另一个线程能读到这个修改的值
​	

####  volatile实现原理

volatile修饰的共享变量写操作 的 汇编代码 会多出一行 lock 前缀的指令。
lock 前缀的指令在多核处理器会引发量件事：
1.将当期处理器 缓存行 的数据写会到系统内存
2.这个写回内存的操作会使在其他CPU里面缓存了该内存地址的数据无效。	


###  synchronized

####  synchronized应用：

1. 对于普通同步方法，锁是当前实例对象
2. 对应静态同步方法，锁是当前class对象
3. 对于同步方法块，锁是 synchronized 括号里面配置的对象

####  synchronized实现原理

​	JVM基于进入和退出 Monitor 对象来实现 方法同步和代码块同步。
​	代码块同步使用 monitorenter 和 monitorexit 指令来实现。
​	任何一个对象都有一个 monitor 与之关联， 当一个 monitor 被持有后，他将处于锁定状态。
​	线程执行到 monitorenter指令时， 将尝试获取对象所对应的 monitor 的所有权，即尝试获取对象的锁。

#####  对象头：

​	synchronized 用的锁 存在java 对象头里



​	

### Java对象头

32位JVM的 Mark Word 的状态变化

<img src="./img/java对象头状态变化.PNG" style="zoom:80%;" />









###   锁的升级与对比

​	在java SE1.6 中锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，这几个锁状态会随着竞争情况逐渐升级。
​	



####   偏向锁

​	为了使 同一线程 多次获得锁 的代价更低 引入偏向锁

​	当一个线程访问同步块并获取锁时，会在 对象头 和 栈帧 中的锁记录里存储 锁偏向的线程id ，以后该线程进入和退出同步块时不需要进行CAS操作来进行加锁和解锁，只需要检查 对象头 是否存在 指向当前线程的偏向锁。

​	存在 表示已获得了锁。 

​	不存在 检查对象头 中偏向锁的标识是否是1(标识当前是否是偏向锁)， 不是1，则使用CAS竞争锁；是1 则尝试使用 CAS 将对象头 的偏向锁指向当前线程	

#####   偏向锁的撤销

​	偏向锁使用了一种等到竞争出现才释放锁的机制。

​	偏向锁撤销需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程 ，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将 对象头设置为无锁状态，如果线程仍然活着，拥有偏向锁的 栈 会被执行， 遍历偏向对象的锁记录， 栈中的锁记录和对象头中的 要么重新偏向于其他线程要么 恢复到 无锁 或者 标记对象不适合作为偏向锁，最后唤醒暂停的线程。



<img src="./img/偏向锁流程.PNG" style="zoom:130%;" />





#### 轻量级锁 

#####  轻量级锁加锁

​	线程在执行同步块之前，jvm会先在当前线程的栈帧中创建用于存储锁记录的空间， 并将对象头中的Mark Word 复制到锁记录中。

​	然后线程尝试使用CAS将 对象头中的 Mark Work替换为指向锁记录的指针，成功当前线程获得锁。失败其他线程竞争锁，当前线程尝试使用自旋来获取锁

##### 轻量级锁解锁

​	轻量级锁解锁时，会使用 CAS操作 将  栈帧中的锁记录 替换回到 对象头中，成功表示没有竞争发生。失败表示存在竞争，锁就会升级成重量级锁。



<img src="./img/轻量级锁流程.PNG" style="zoom:130%;" />




#### 锁的优缺点对比

偏向锁
	优点：加锁解锁不需要额外消耗，和执行非同步方法相比仅存在纳秒的差距
	缺点：如果线程间存在锁竞争会带来额外的 锁撤销的消耗
	适用场景：适用于只有一个线程访问的同步块场景
轻量级锁
	优点：竞争线程不会阻塞，提高了程序的相应速度
	缺点：如果始终得不到锁的线程，使用自旋消耗CPU
	适用场景：追求相应时间，同步块执行速度非常快
重量级锁 
	优点：线程竞争不使用自旋，不会消耗CPU
	缺点：线程阻塞，相应时间缓慢
	适用场景：追求吞吐量，同步块执行速度较长

