####    虚拟机类加载机制

​	虚拟机把class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。

#####   类的声明周期

加载 -> 连接 （验证，准备，解析） -> 初始化 -> 使用 -> 卸载

#### 类加载过程

#####  加载

加载过程

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class 对象，作为方法区这个类的各种数据结构的访问入口



##### 链接

###### 验证

文件格式验证；

元数据验证；

字节码验证；

###### 准备

准备阶段正式为**类变量**分配内存并设置类变量**初始值**

​	这时候进行内存分配的仅包括类变量( 被 static 修饰的变量)，不包括实例变量，实例变量将会在对象实例化的时，随着对象一起分配在java堆中。

​	这里的初始值一般情况下是数据类型的零值。 int 的初始值为0 ， boolean 的初始值为 false。

​		public static int value = 123; //准备阶段过后初始值为0，

​	如果字段类型属性表中存在ConstantValue属性，那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值。

​		public static **final** int value = 123; //准备阶段就会将value的值赋值为123

###### 解析

解析阶段将常量池内的符号引用替换为直接引用的过程



#####  初始化

初始化阶段是执行类构造器`<clinit>()`方法的过程

 1. `<clinit>() `方法是编译器自动收集类中所有 **类变量的赋值动作** 和 **静态语句块中的语句** 产生的。静态语句块只能方位到定义在静态语句块之前的变量，定义在他之后的变量，**在前面的静态语句块可以赋值单不能访问**。

    ```java
    public class Test{
        static {
            i = 0; //给变量赋值可以正常编译通过
            System.out.print(i);//这句编译器会提示 “非法向前引用”
        }
        static int i = 1;
    }
    ```

    

 2. `<clinit>()`方法与类构造函数不同，他不需要显示的调用父类构造器，**虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已将执行完毕**。也就是说父类中定义的静态语句块要优先于子类的变量赋值操作。

 3. 执行接口的`<clinit>()`方法不需要先执行父类接口的`<clinit>()`方法，只有当父类接口中定义的变量使用时，父类接口才会初始化。接口的实现类在初始化也一样不会执行接口的`<clinit>()`方法。

 4. 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步。



